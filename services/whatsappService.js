import { makeWASocket, DisconnectReason, useMultiFileAuthState } from '@whiskeysockets/baileys';
import { Boom } from '@hapi/boom';
import path from 'path';
import fs from 'fs';
import qrcode from 'qrcode-terminal';

class WhatsAppService {
  constructor() {
    if (WhatsAppService.instance) {
      return WhatsAppService.instance;
    }
    
    this.sock = null;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 3;
    this.isInitializing = false;
    this.currentQR = null;
    this.groupMemories = new Map(); // Store last 10 messages per group/chat
    
    // Rate limiting
    this.messageRequests = new Map(); // userId -> [timestamps]
    this.imageRequests = new Map(); // userId -> [timestamps]
    
    WhatsAppService.instance = this;
  }

  async initialize() {
    if (this.isInitializing) {
      console.log('‚ö†Ô∏è WhatsApp initialization already in progress...');
      return;
    }
    
    if (this.isConnected) {
      console.log('‚úÖ WhatsApp already connected');
      return;
    }
    
    this.isInitializing = true;
    
    try {
      // Check if session folder exists
      if (!fs.existsSync('./session')) {
        console.log('üì± Session folder not found. QR code scanning required.');
        console.log('üîÑ Please scan the QR code below with your WhatsApp:');
      }
      
      const { state, saveCreds } = await useMultiFileAuthState('./session');
      
      this.sock = makeWASocket({
        auth: state,
        printQRInTerminal: !fs.existsSync('./session')
      });

      this.sock.ev.on('creds.update', saveCreds);
      this.sock.ev.on('connection.update', (update) => {
        const { qr } = update;
        
        if (qr) {
          console.log('üì± Scan this QR code with WhatsApp:');
          qrcode.generate(qr, { small: true });
          this.currentQR = qr; // Store QR for web display
        }
        
        this.handleConnection(update);
      });

      // Listen for incoming messages
      this.sock.ev.on('messages.upsert', this.handleIncomingMessage.bind(this));
      
      // Listen for poll responses
      this.sock.ev.on('messages.update', this.handlePollUpdate.bind(this));
      
      console.log('WhatsApp service initialized');
    } catch (error) {
      console.error('WhatsApp initialization error:', error);
    } finally {
      this.isInitializing = false;
    }
  }

  handleConnection(update) {
    const { connection, lastDisconnect } = update;
    
    if (connection === 'close') {
      const statusCode = (lastDisconnect?.error instanceof Boom)?.output?.statusCode;
      const shouldReconnect = statusCode !== DisconnectReason.loggedOut;
      
      console.log('Connection closed due to ', lastDisconnect?.error?.message || 'Unknown error');
      
      // Handle specific error cases
      if (lastDisconnect?.error?.message?.includes('conflict')) {
        console.log('‚ö†Ô∏è WhatsApp Web conflict detected. Another session is active.');
        console.log('üí° Close other WhatsApp Web sessions and restart server.');
        return; // Don't reconnect on conflict
      }
      
      if (shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
        this.reconnectAttempts++;
        console.log(`üîÑ Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
        setTimeout(() => this.initialize(), 5000); // Wait 5 seconds before reconnecting
      } else {
        console.log('‚ùå Max reconnection attempts reached or logged out');
      }
      
      this.isConnected = false;
    } else if (connection === 'open') {
      console.log('‚úÖ WhatsApp connected');
      this.isConnected = true;
      this.reconnectAttempts = 0; // Reset counter on successful connection
    }
  }

  async sendMessage(phoneNumber, message) {
    if (!this.isConnected || !this.sock) {
      console.log('‚ùå WhatsApp not connected');
      return { success: false, error: 'WhatsApp not connected' };
    }
    
    try {
      // Always remove + sign if present
      const cleanPhone = phoneNumber.replace('+', '');
      const jid = cleanPhone.includes('@') ? cleanPhone : `${cleanPhone}@s.whatsapp.net`;
      console.log(`üì§ Sending to ${jid}: ${message}`);
      
      // Simple send without complex retry logic
      const result = await this.sock.sendMessage(jid, { 
        text: message 
      });
      
      console.log('‚úÖ Message sent:', result?.key?.id || 'success');
      return { success: true };
      
    } catch (error) {
      console.error('‚ùå Send failed:', error.message);
      
      // Try once more with different format
      try {
        const cleanRetryPhone = phoneNumber.replace('+', '');
        const jid = `${cleanRetryPhone}@s.whatsapp.net`;
        console.log(`üîÑ Retry with format: ${jid}`);
        
        await this.sock.sendMessage(jid, { text: message });
        console.log('‚úÖ Retry successful');
        return { success: true };
      } catch (retryError) {
        console.error('‚ùå Retry also failed:', retryError.message);
        return { success: false, error: `Both attempts failed: ${error.message}` };
      }
    }
  }



  async broadcastMessage(phoneNumbers, message) {
    if (!this.isConnected || !phoneNumbers.length) return false;
    
    const results = [];
    for (const phone of phoneNumbers) {
      const result = await this.sendMessage(phone, message);
      results.push({ phone, success: result });
    }
    return results;
  }

  getQRCode() {
    return this.currentQR;
  }

  getConnectionStatus() {
    return {
      isConnected: this.isConnected,
      hasQR: !!this.currentQR,
      isInitializing: this.isInitializing
    };
  }

  async getGroups() {
    if (!this.isConnected || !this.sock) {
      return { success: false, error: 'WhatsApp not connected' };
    }

    try {
      const chats = await this.sock.groupFetchAllParticipating();
      const groups = Object.values(chats).map(group => ({
        id: group.id,
        name: group.subject,
        participants: group.participants?.length || 0,
        participantList: group.participants || []
      }));
      
      return { success: true, groups };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async getGroupInfo(groupId) {
    if (!this.isConnected || !this.sock) {
      return { success: false, error: 'WhatsApp not connected' };
    }

    try {
      const groupMetadata = await this.sock.groupMetadata(groupId);
      return {
        success: true,
        info: {
          id: groupMetadata.id,
          name: groupMetadata.subject,
          description: groupMetadata.desc,
          participants: groupMetadata.participants,
          admins: groupMetadata.participants.filter(p => p.admin),
          createdAt: new Date(groupMetadata.creation * 1000)
        }
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  findGroupByName(groupName) {
    try {
      const chats = this.sock?.groupFetchAllParticipating ? 
        Object.values(this.sock.groupFetchAllParticipating()) : [];
      
      return chats.find(group => 
        group.subject?.toLowerCase().includes(groupName.toLowerCase())
      );
    } catch (error) {
      console.error('‚ùå Error finding group:', error);
      return null;
    }
  }

  async sendGroupMessage(groupId, message, options = {}) {
    if (!this.isConnected || !this.sock) {
      return { success: false, error: 'WhatsApp not connected' };
    }

    try {
      console.log(`üì§ Sending group message to ${groupId}: ${message}`);
      
      const messageContent = { text: message };
      
      // Add mentions if provided
      if (options.mentions && options.mentions.length > 0) {
        messageContent.mentions = options.mentions;
      }
      
      await this.sock.sendMessage(groupId, messageContent);
      console.log('‚úÖ Group message sent successfully');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Group message failed:', error.message);
      return { success: false, error: error.message };
    }
  }

  async sendFormattedMessage(chatId, text, formatting = {}) {
    if (!this.isConnected || !this.sock) {
      return { success: false, error: 'WhatsApp not connected' };
    }

    try {
      let formattedText = text;
      
      // Apply formatting
      if (formatting.bold) formattedText = `*${formattedText}*`;
      if (formatting.italic) formattedText = `_${formattedText}_`;
      if (formatting.monospace) formattedText = `\`\`\`${formattedText}\`\`\``;
      if (formatting.strikethrough) formattedText = `~${formattedText}~`;
      
      await this.sock.sendMessage(chatId, { text: formattedText });
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async sendPoll(chatId, question, options) {
    if (!this.isConnected || !this.sock) {
      return { success: false, error: 'WhatsApp not connected' };
    }

    try {
      const poll = {
        name: question,
        values: options,
        selectableCount: 1
      };
      
      await this.sock.sendMessage(chatId, { poll });
      console.log(`üìä Poll sent: ${question}`);
      return { success: true };
    } catch (error) {
      console.error('‚ùå Poll failed:', error.message);
      return { success: false, error: error.message };
    }
  }

  async sendMessageToGroup(groupNameOrId, message, options = {}) {
    try {
      let targetGroupId;
      
      // Check if it's already a group ID
      if (groupNameOrId.includes('@g.us')) {
        targetGroupId = groupNameOrId;
      } else {
        // Find group by name
        const group = this.findGroupByName(groupNameOrId);
        if (!group) {
          return { success: false, error: `Group '${groupNameOrId}' not found` };
        }
        targetGroupId = group.id;
      }
      
      return await this.sendGroupMessage(targetGroupId, message, options);
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async sendPollToGroup(groupNameOrId, question, options) {
    try {
      let targetGroupId;
      
      if (groupNameOrId.includes('@g.us')) {
        targetGroupId = groupNameOrId;
      } else {
        const group = this.findGroupByName(groupNameOrId);
        if (!group) {
          return { success: false, error: `Group '${groupNameOrId}' not found` };
        }
        targetGroupId = group.id;
      }
      
      return await this.sendPoll(targetGroupId, question, options);
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async handleIncomingMessage(m) {
    try {
      const message = m.messages[0];
      if (!message || message.key.fromMe) return; // Ignore our own messages

      const messageText = message.message?.conversation || 
                         message.message?.extendedTextMessage?.text || '';
      
      // Check for quoted/replied message
      const quotedMessage = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;
      let quotedText = '';
      if (quotedMessage) {
        quotedText = quotedMessage.conversation || 
                    quotedMessage.extendedTextMessage?.text || 
                    quotedMessage.imageMessage?.caption || 
                    '[Media message]';
      }
      
      // Extract mentioned users (native WhatsApp mentions)
      const userMentionedJids = message.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
      let mentionContext = '';
      if (userMentionedJids.length > 0 && isGroup) {
        try {
          const groupMetadata = await this.sock.groupMetadata(chatId);
          const mentionedNames = userMentionedJids.map(jid => {
            const participant = groupMetadata.participants.find(p => p.id === jid);
            return participant?.notify || participant?.name || jid.split('@')[0];
          }).join(', ');
          mentionContext = ` (mentioning: ${mentionedNames})`;
        } catch (error) {
          console.log('Could not fetch group metadata for mentions');
        }
      }
      
      const chatId = message.key.remoteJid;
      const isGroup = chatId.includes('@g.us');
      
      // Extract phone number properly
      let senderPhone;
      let isWebUser = false;
      
      if (isGroup) {
        const participant = message.key.participant || '';
        
        if (participant.includes('@lid')) {
          // WhatsApp Web/Desktop user - allow without registration check
          senderPhone = participant;
          isWebUser = true;
          console.log(`üåê WhatsApp Web user detected: ${participant}`);
        } else {
          senderPhone = this.extractPhoneNumber(participant);
        }
      } else {
        if (chatId.includes('@lid')) {
          senderPhone = chatId;
          isWebUser = true;
          console.log(`üåê WhatsApp Web user detected: ${chatId}`);
        } else {
          senderPhone = this.extractPhoneNumber(chatId);
        }
      }
      
      console.log(`üì± Raw participant: ${message.key.participant}`);
      console.log(`üì± Extracted phone: ${senderPhone}`);
      console.log(`üåê Is Web User: ${isWebUser}`);
      
      const senderName = message.pushName || senderPhone;
      
      // Check for different message types
      const hasImage = message.message?.imageMessage;
      const hasVideo = message.message?.videoMessage;
      const hasAudio = message.message?.audioMessage;
      const hasDocument = message.message?.documentMessage;
      const hasSticker = message.message?.stickerMessage;
      const imageCaption = message.message?.imageMessage?.caption || '';
      
      // Store message in memory (last 10 messages) - only text and images with captions
      let memoryMessage = null;
      
      if (messageText && messageText.trim()) {
        // Regular text message
        memoryMessage = messageText;
      } else if (hasImage && imageCaption) {
        // Image with caption
        memoryMessage = `[Image: ${imageCaption}]`;
      } else if (hasImage) {
        // Image without caption - skip from memory
        console.log(`üì∑ Skipping image without caption from ${senderName}`);
      } else if (hasVideo || hasAudio || hasDocument || hasSticker) {
        // Other media types - skip from memory
        console.log(`üìé Skipping ${hasVideo ? 'video' : hasAudio ? 'audio' : hasDocument ? 'document' : 'sticker'} from ${senderName}`);
      }
      
      // Only add to memory if we have a valid message
      if (memoryMessage) {
        this.addToMemory(chatId, {
          sender: senderName,
          message: memoryMessage,
          timestamp: new Date(),
          isBot: false
        });
      }
      
      // Check for NeuraX mentions - both @n and native WhatsApp mentions
      const botMentionedJids = message.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
      const botJid = this.sock?.user?.id?.replace(':0', '@s.whatsapp.net');
      const isMentioned = botMentionedJids.includes(botJid);
      
      const shouldRespond = messageText.startsWith('@n ') || imageCaption.startsWith('@n ') || isMentioned || !isGroup;
      
      if (shouldRespond) {
        // Check rate limits first
        const userId = senderPhone || chatId;
        const rateLimitResult = this.checkRateLimit(userId, 'message');
        
        if (!rateLimitResult.allowed) {
          const errorMsg = isGroup ? `@${senderName} Please wait ${rateLimitResult.waitTime} seconds before sending another message! ‚è∞` : `Please wait ${rateLimitResult.waitTime} seconds before sending another message! ‚è∞`;
          
          if (isGroup) {
            await this.sendGroupMessage(chatId, errorMsg);
          } else {
            await this.sendMessage(chatId, errorMsg);
          }
          return;
        }
        
        // React to messages only when bot is mentioned or in personal chat
        await this.autoReactToMessage(message, messageText);
        // Check if user is registered (skip check for WhatsApp Web users)
        if (!isWebUser) {
          const isRegistered = await this.checkUserRegistration(senderPhone);
          
          if (!isRegistered) {
            await this.handleUnregisteredUser(chatId, senderName, isGroup);
            return;
          }
        } else {
          console.log(`üåê Allowing WhatsApp Web user ${senderName} without registration check`);
        }
        
        let actualMessage;
        if (messageText.startsWith('@n ')) {
          actualMessage = messageText.substring(3);
        } else if (imageCaption.startsWith('@n ')) {
          actualMessage = imageCaption.substring(3);
        } else if (isMentioned) {
          // For native mentions, use the full message text
          actualMessage = messageText.trim();
        } else if (!isGroup) {
          // In personal chat, respond to any message
          actualMessage = messageText || imageCaption;
        }
        
        if (actualMessage) {
          if (actualMessage.startsWith('/help')) {
            // Handle help command
            await this.handleHelpRequest(chatId, senderName, isGroup);
          } else if (actualMessage.toLowerCase().includes('help') || actualMessage.toLowerCase().includes('manual') || actualMessage.toLowerCase().includes('how to use') || actualMessage === '') {
            // Tell user about help command
            await this.handleHelpInfo(chatId, senderName, isGroup);
          } else if (hasImage && (actualMessage.startsWith('/vision') || actualMessage.includes('analyze') || actualMessage.includes('describe'))) {
            // Handle vision request
            await this.handleVisionRequest(message, chatId, senderName, actualMessage, isGroup);
          } else if (actualMessage.startsWith('/search ')) {
            // Handle web search
            const query = actualMessage.substring(8); // Remove '/search '
            await this.handleWebSearch(chatId, senderName, query, isGroup);
          } else if (actualMessage.startsWith('/send ')) {
            // Handle cross-group messaging: /send [group_name] [message]
            const sendContent = actualMessage.substring(6).trim();
            const spaceIndex = sendContent.indexOf(' ');
            
            if (spaceIndex === -1) {
              const errorMsg = isGroup ? `@${senderName} Format: /send [group_name] [message]\nExample: /send Study Group Hello everyone!` : 'Format: /send [group_name] [message]\nExample: /send Study Group Hello everyone!';
              
              if (isGroup) {
                await this.sendGroupMessage(chatId, errorMsg);
              } else {
                await this.sendMessage(chatId, errorMsg);
              }
              return;
            }
            
            const targetGroupName = sendContent.substring(0, spaceIndex).trim();
            const messageToSend = sendContent.substring(spaceIndex + 1).trim();
            
            if (!messageToSend) {
              const errorMsg = isGroup ? `@${senderName} Please provide a message to send!` : 'Please provide a message to send!';
              
              if (isGroup) {
                await this.sendGroupMessage(chatId, errorMsg);
              } else {
                await this.sendMessage(chatId, errorMsg);
              }
              return;
            }
            
            const result = await this.sendMessageToGroup(targetGroupName, `üì® From ${senderName}: ${messageToSend}`);
            
            if (result.success) {
              const confirmMsg = isGroup ? `@${senderName} ‚úÖ Message sent to "${targetGroupName}"` : `‚úÖ Message sent to "${targetGroupName}"`;
              
              if (isGroup) {
                await this.sendGroupMessage(chatId, confirmMsg);
              } else {
                await this.sendMessage(chatId, confirmMsg);
              }
            } else {
              const errorMsg = isGroup ? `@${senderName} ‚ùå Failed to send: ${result.error}` : `‚ùå Failed to send: ${result.error}`;
              
              if (isGroup) {
                await this.sendGroupMessage(chatId, errorMsg);
              } else {
                await this.sendMessage(chatId, errorMsg);
              }
            }
          } else if (actualMessage.startsWith('/poll ')) {
            // Handle poll creation
            const pollContent = actualMessage.substring(6).trim();
            const lines = pollContent.split('\n');
            const question = lines[0];
            const options = lines.slice(1)
              .filter(line => line.trim().startsWith('-'))
              .map(line => line.trim().substring(1).trim())
              .slice(0, 12); // WhatsApp limit

            if (options.length < 2) {
              const errorMsg = isGroup ? `@${senderName} Poll needs at least 2 options. Format:\n/poll Question?\n- Option 1\n- Option 2` : 'Poll needs at least 2 options. Format:\n/poll Question?\n- Option 1\n- Option 2';
              
              if (isGroup) {
                await this.sendGroupMessage(chatId, errorMsg);
              } else {
                await this.sendMessage(chatId, errorMsg);
              }
              return;
            }

            const result = await this.sendPoll(chatId, question, options);
            if (!result.success) {
              const errorMsg = isGroup ? `@${senderName} Failed to create poll: ${result.error}` : `Failed to create poll: ${result.error}`;
              if (isGroup) {
                await this.sendGroupMessage(chatId, errorMsg);
              } else {
                await this.sendMessage(chatId, errorMsg);
              }
            }
          } else if (actualMessage.startsWith('/generate ') || actualMessage.startsWith('/image ')) {
            // Handle image generation
            const prompt = actualMessage.startsWith('/generate ') ? 
              actualMessage.substring(10).trim() : actualMessage.substring(7).trim();
            
            if (!prompt) {
              const errorMsg = isGroup ? `@${senderName} Please provide a description after /generate. Example: @n /generate sunset over mountains` : 'Please provide a description after /generate. Example: /generate sunset over mountains';
              
              if (isGroup) {
                await this.sendGroupMessage(chatId, errorMsg);
              } else {
                await this.sendMessage(chatId, errorMsg);
              }
              return;
            }
            
            // Check image generation rate limit
            const userId = senderPhone || chatId;
            const imageRateLimit = this.checkRateLimit(userId, 'image');
            
            if (!imageRateLimit.allowed) {
              const minutes = Math.floor(imageRateLimit.waitTime / 60);
              const seconds = imageRateLimit.waitTime % 60;
              const timeStr = minutes > 0 ? `${minutes} minutes ${seconds} seconds` : `${seconds} seconds`;
              const errorMsg = isGroup ? `@${senderName} Image generation limit reached! Please wait ${timeStr} before generating another image! üé®‚è∞` : `Image generation limit reached! Please wait ${timeStr} before generating another image! üé®‚è∞`;
              
              if (isGroup) {
                await this.sendGroupMessage(chatId, errorMsg);
              } else {
                await this.sendMessage(chatId, errorMsg);
              }
              return;
            }
            
            await this.handleImageGeneration(chatId, senderName, prompt, isGroup);
            return; // Important: Return here to prevent falling through to regular chat
          } else {
            // Handle regular NeuraX mention
            if (isGroup) {
              await this.handleNeuraXMention(chatId, senderName, actualMessage, true, quotedText, mentionContext);
            } else {
              await this.handleNeuraXMention(chatId, senderName, actualMessage, false, quotedText, mentionContext);
              // Only save to inbox for registered users (not web users)
              if (!isWebUser) {
                await this.saveToUserInbox(senderPhone, senderName, actualMessage);
              }
            }
          }
        }
      }
    } catch (error) {
      console.error('‚ùå Error handling incoming message:', error);
    }
  }

  addToMemory(chatId, messageData) {
    if (!this.groupMemories.has(chatId)) {
      this.groupMemories.set(chatId, []);
    }
    
    const messages = this.groupMemories.get(chatId);
    messages.push(messageData);
    
    // Keep only last 10 messages
    if (messages.length > 10) {
      messages.shift();
    }
    
    this.groupMemories.set(chatId, messages);
  }

  async handleNeuraXMention(chatId, senderName, message, isGroup, quotedText = '', mentionContext = '') {
    try {
      console.log(`ü§ñ NeuraX mentioned by ${senderName}: ${message}`);
      
      // Show typing indicator
      await this.sendTypingIndicator(chatId);
      
      // Get conversation history
      const history = this.groupMemories.get(chatId) || [];
      
      // Create context for AI
      const conversationHistory = history.slice(-9).map(msg => ({
        role: msg.isBot ? 'assistant' : 'user',
        content: `${msg.sender}: ${msg.message}`
      }));
      
      // Add current message with quoted and mention context
      let userMessage = `${senderName}${mentionContext}`;
      if (quotedText) {
        userMessage += ` (replying to: "${quotedText}")`;
      }
      userMessage += `: ${message}`;
      
      conversationHistory.push({
        role: 'user',
        content: userMessage
      });
      
      // Get AI response
      const aiResponse = await this.getNeuraXResponse(message, conversationHistory, senderName, isGroup);
      
      // Send response
      const responseText = isGroup ? `@${senderName} ${aiResponse}` : aiResponse;
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, responseText);
      } else {
        await this.sendMessage(chatId, responseText);
      }
      
      // Stop typing indicator
      await this.stopTypingIndicator(chatId);
      
      // Add bot response to memory
      this.addToMemory(chatId, {
        sender: 'NeuraX',
        message: responseText,
        timestamp: new Date(),
        isBot: true
      });
      
    } catch (error) {
      console.error('‚ùå Error handling NeuraX mention:', error);
      const errorMsg = isGroup ? `@${senderName} Sorry, I'm having technical difficulties right now! ü§ñüíî` : 'Sorry, I\'m having technical difficulties right now! ü§ñüíî';
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, errorMsg);
      } else {
        await this.sendMessage(chatId, errorMsg);
      }
    }
  }

  async handleHelpInfo(chatId, senderName, isGroup) {
    try {
      const helpInfo = `ü§ñ Hi! I'm NeuraX, your AI assistant. For detailed instructions, use: *@n /help*

Quick commands:
‚Ä¢ @n /help - Full manual
‚Ä¢ @n /search [query] - Web search
‚Ä¢ @n /generate [prompt] - Create images
‚Ä¢ @n /vision + image - Analyze images
‚Ä¢ @n [message] - Chat with me`;
      
      const responseText = isGroup ? `@${senderName} ${helpInfo}` : helpInfo;
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, responseText);
      } else {
        await this.sendMessage(chatId, responseText);
      }
      
    } catch (error) {
      console.error('‚ùå Help info error:', error);
    }
  }

  async handleHelpRequest(chatId, senderName, isGroup) {
    try {
      console.log(`‚ùì Help request from ${senderName}`);
      
      const helpText = `ü§ñ *NeuraX AI Assistant - User Manual*

üëã Hi! I'm NeuraX, your AI assistant from Neuronerds Quiz platform. Here's how to use me:

*üí¨ Basic Chat:*
‚Ä¢ @n [your message] - Chat with me normally
‚Ä¢ Example: @n hello, how are you?

*üîç Web Search:*
‚Ä¢ @n /search [query] - Search the web
‚Ä¢ Example: @n /search latest AI news

*üìä Create Polls:*
‚Ä¢ @n /poll [question]
‚Ä¢ Format options with dashes:
‚Ä¢ Example: @n /poll Favorite subject?
- Math
- Physics
- Chemistry

*üì® Send to Group:*
‚Ä¢ @n /send [group_name] [message]
‚Ä¢ Example: @n /send Study Group Hello everyone!

*üé® Image Generation:*
‚Ä¢ @n /generate [description] - Create images
‚Ä¢ @n /image [description] - Alternative command
‚Ä¢ Example: @n /generate sunset over mountains

*üëÅÔ∏è Vision Analysis:*
‚Ä¢ Send image + @n /vision - Analyze images
‚Ä¢ @n analyze this image - Describe photos
‚Ä¢ Works with: OCR, charts, objects, scenes

*üéÆ About Neuronerds Quiz:*
‚Ä¢ Interactive quiz platform with battles
‚Ä¢ Badge system & leaderboards
‚Ä¢ Real-time competitions with friends
‚Ä¢ Advanced AI-powered learning

*üì± Features:*
‚Ä¢ I remember our last 10 messages
‚Ä¢ I react to your messages automatically
‚Ä¢ Available 24/7 in groups & personal chats

*Need more help?* Just ask: @n help with [topic]`;
      
      const responseText = isGroup ? `@${senderName}\n${helpText}` : helpText;
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, responseText);
      } else {
        await this.sendMessage(chatId, responseText);
      }
      
      // Add to memory
      this.addToMemory(chatId, {
        sender: 'NeuraX',
        message: '[Help Manual Sent]',
        timestamp: new Date(),
        isBot: true
      });
      
    } catch (error) {
      console.error('‚ùå Help error:', error);
      const errorMsg = isGroup ? `@${senderName} Sorry, I can't show the manual right now! Try: @n /help` : 'Sorry, I can\'t show the manual right now! Try: @n /help';
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, errorMsg);
      } else {
        await this.sendMessage(chatId, errorMsg);
      }
    }
  }

  async getNeuraXResponse(message, conversationHistory, senderName, isGroup) {
    try {
      const axios = (await import('axios')).default;
      const apiUrl = process.env.API_URL || process.env.VITE_API_URL || 'http://localhost:5000';
      
      const systemPrompt = isGroup 
        ? `You are NeuraX, an AI assistant for WhatsApp group *The NeuroNERDS* - a student community from Chattogram College, Bangladesh.

üéØ **WhatsApp Group Guidelines:**
‚Ä¢ Keep responses SHORT (1-2 lines max)
‚Ä¢ Use WhatsApp formatting: *bold*, _italic_, ~strikethrough~
‚Ä¢ Add relevant emojis for engagement
‚Ä¢ Be casual and friendly like a group member
‚Ä¢ Respond quickly to maintain conversation flow

üì± **WhatsApp Formatting:**
‚Ä¢ *Bold text* for emphasis
‚Ä¢ _Italic text_ for subtle points
‚Ä¢ Use bullet points (‚Ä¢) for lists
‚Ä¢ Add emojis naturally üòä
‚Ä¢ Keep paragraphs short
‚Ä¢ Use line breaks for readability

ü§ñ **Your Role:**
‚Ä¢ Help with studies and homework
‚Ä¢ Answer questions quickly
‚Ä¢ Share study tips
‚Ä¢ Be encouraging and motivational
‚Ä¢ Remember you're chatting in a group

Be helpful, concise, and engaging! üöÄ`
        : `You are NeuraX, an AI assistant for personal WhatsApp chat with ${senderName}. You're part of Neuronerds Quiz platform.

üë• **Community Info:**
*The NeuroNERDS* - Student community from Chattogram College
‚Ä¢ *Akhyar Fardin* ‚Äì CEO & Admin
‚Ä¢ *Ahmed Azmain Mahtab* ‚Äì Developer & Management Lead  
‚Ä¢ *Md. Tanvir Mahtab* ‚Äì Co-founder & Managing Director
‚Ä¢ Students from Intermediate classes

üì± **WhatsApp Personal Chat Style:**
‚Ä¢ Use WhatsApp formatting: *bold*, _italic_, ~strikethrough~
‚Ä¢ Keep responses conversational and friendly
‚Ä¢ Add emojis naturally for warmth
‚Ä¢ Be more detailed than group responses
‚Ä¢ Use proper spacing and line breaks
‚Ä¢ Reply in Bengali if user prefers

üéØ **Your Approach:**
‚Ä¢ Be helpful and educational
‚Ä¢ Share study strategies
‚Ä¢ Provide gentle motivation
‚Ä¢ Answer questions thoroughly
‚Ä¢ Use smooth call-to-actions like "Want to know more? üòä"

Be friendly, knowledgeable, and supportive! ‚ú®`;
      
      const response = await axios.post(`${apiUrl}/api/ai-chat`, {
        message: message,
        model: 'qwen/qwen3-32b',
        systemPrompt: systemPrompt,
        conversationHistory: conversationHistory
      });
      
      return response.data.response;
    } catch (error) {
      console.error('‚ùå Error getting AI response:', error);
      return 'I\'m having trouble thinking right now! ü§î Try again in a moment.';
    }
  }

  async handleVisionRequest(message, chatId, senderName, prompt, isGroup) {
    try {
      console.log(`üëÅÔ∏è Vision request from ${senderName}`);
      
      // Show typing indicator
      await this.sendTypingIndicator(chatId);
      
      // Download image using correct Baileys method
      const { downloadMediaMessage } = await import('@whiskeysockets/baileys');
      const imageBuffer = await downloadMediaMessage(message, 'buffer', {});
      const base64Image = imageBuffer.toString('base64');
      
      // Get vision analysis
      const analysis = await this.getVisionAnalysis(base64Image, prompt);
      
      const responseText = isGroup ? `@${senderName} ${analysis}` : analysis;
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, responseText);
      } else {
        await this.sendMessage(chatId, responseText);
      }
      
      // Stop typing indicator
      await this.stopTypingIndicator(chatId);
      
      // Add to memory
      this.addToMemory(chatId, {
        sender: 'NeuraX',
        message: responseText,
        timestamp: new Date(),
        isBot: true
      });
      
    } catch (error) {
      console.error('‚ùå Vision error:', error);
      let errorMsg;
      
      if (error.message?.includes('downloadMediaMessage')) {
        errorMsg = isGroup ? `@${senderName} Please send the image again - I had trouble downloading it! üì∑` : 'Please send the image again - I had trouble downloading it! üì∑';
      } else {
        errorMsg = isGroup ? `@${senderName} Sorry, I couldn't analyze the image! üëÅÔ∏èüíî` : 'Sorry, I couldn\'t analyze the image! üëÅÔ∏èüíî';
      }
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, errorMsg);
      } else {
        await this.sendMessage(chatId, errorMsg);
      }
    }
  }

  async handleWebSearch(chatId, senderName, query, isGroup) {
    try {
      console.log(`üîç Web search from ${senderName}: ${query}`);
      
      // Show typing indicator
      await this.sendTypingIndicator(chatId);
      
      const searchResults = await this.performWebSearch(query);
      
      const responseText = isGroup ? `@${senderName} ${searchResults}` : searchResults;
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, responseText);
      } else {
        await this.sendMessage(chatId, responseText);
      }
      
      // Stop typing indicator
      await this.stopTypingIndicator(chatId);
      
      
      // Add to memory
      this.addToMemory(chatId, {
        sender: 'NeuraX',
        message: responseText,
        timestamp: new Date(),
        isBot: true
      });
      
    } catch (error) {
      console.error('‚ùå Search error:', error);
      const errorMsg = isGroup ? `@${senderName} Sorry, I couldn't search right now! üîçüíî` : 'Sorry, I couldn\'t search right now! üîçüíî';
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, errorMsg);
      } else {
        await this.sendMessage(chatId, errorMsg);
      }
    }
  }

  async getVisionAnalysis(base64Image, prompt) {
    try {
      const axios = (await import('axios')).default;
      const apiUrl = process.env.API_URL || process.env.VITE_API_URL || 'http://localhost:5000';
      
      // Convert base64 to buffer for FormData
      const imageBuffer = Buffer.from(base64Image, 'base64');
      const FormData = (await import('form-data')).default;
      const formData = new FormData();
      
      formData.append('image', imageBuffer, { filename: 'image.jpg', contentType: 'image/jpeg' });
      formData.append('prompt', prompt || 'Analyze this image and describe what you see in detail.');
      
      const response = await axios.post(`${apiUrl}/api/vision/analyze`, formData, {
        headers: {
          ...formData.getHeaders()
        }
      });
      
      return response.data.analysis || 'I can see the image but couldn\'t analyze it properly.';
    } catch (error) {
      console.error('‚ùå Vision API error:', error);
      return 'I\'m having trouble with my vision right now! üëÅÔ∏èü§ñ';
    }
  }

  async performWebSearch(query) {
    try {
      const axios = (await import('axios')).default;
      const apiUrl = process.env.API_URL || process.env.VITE_API_URL || 'http://localhost:5000';
      
      const response = await axios.post(`${apiUrl}/api/web-search`, {
        query: query
      });
      
      const results = response.data.results;
      if (!results || results.length === 0) {
        return `No results found for "${query}" üîç`;
      }
      
      // Format top 3 results
      const topResults = results.slice(0, 3).map((result, index) => 
        `${index + 1}. ${result.title}\n${result.snippet}\nüîó ${result.url}`
      ).join('\n\n');
      
      return `üîç Search results for "${query}":\n\n${topResults}`;
    } catch (error) {
      console.error('‚ùå Web search error:', error);
      return 'I\'m having trouble searching the web right now! üîçü§ñ';
    }
  }

  async handleImageGeneration(chatId, senderName, prompt, isGroup) {
    try {
      console.log(`üé® Image generation from ${senderName}: ${prompt}`);
      
      // Show typing indicator
      await this.sendTypingIndicator(chatId);
      
      const imageUrl = await this.generateImage(prompt);
      const responseText = isGroup ? `@${senderName} üé® Generated image: "${prompt}"` : `üé® Generated image: "${prompt}"`;
      
      // Send image with caption
      const result = await this.sendImageMessage(chatId, imageUrl, responseText);
      
      if (!result.success) {
        throw new Error('Failed to send image message');
      }
      
      console.log('‚úÖ Image generated and sent successfully');
      
    } catch (error) {
      console.error('‚ùå Image generation error:', error);
      
      let errorMsg;
      if (error.message === 'Prompt too short') {
        errorMsg = isGroup ? `@${senderName} Please provide a more detailed description (at least 3 characters)` : 'Please provide a more detailed description (at least 3 characters)';
      } else if (error.response?.status === 429) {
        errorMsg = isGroup ? `@${senderName} Image generation limit reached. Please try again later! ‚è∞` : 'Image generation limit reached. Please try again later! ‚è∞';
      } else if (error.response?.status === 401) {
        errorMsg = isGroup ? `@${senderName} Image generation service unavailable. Please try again later! üîß` : 'Image generation service unavailable. Please try again later! üîß';
      } else {
        errorMsg = isGroup ? `@${senderName} Sorry, I couldn't generate that image! The service might be unavailable. üé®üíî` : 'Sorry, I couldn\'t generate that image! The service might be unavailable. üé®üíî';
      }
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, errorMsg);
      } else {
        await this.sendMessage(chatId, errorMsg);
      }
    } finally {
      // Stop typing indicator
      await this.stopTypingIndicator(chatId);
    }
  }

  async generateImage(prompt) {
    try {
      if (!prompt || prompt.trim().length < 3) {
        throw new Error('Prompt too short');
      }
      
      console.log(`üìû Calling image generation API with prompt: ${prompt}`);
      
      const axios = (await import('axios')).default;
      const apiUrl = process.env.API_URL || process.env.VITE_API_URL || 'http://localhost:5000';
      
      const response = await axios.post(`${apiUrl}/api/generate-image`, {
        prompt: prompt.trim()
      });
      
      console.log(`üìû API Response:`, response.data);
      
      if (!response.data.imageUrl) {
        throw new Error('No image URL returned from API');
      }
      
      console.log(`‚úÖ Image URL received: ${response.data.imageUrl}`);
      return response.data.imageUrl;
    } catch (error) {
      console.error('‚ùå Image generation API error:', error.response?.data || error.message);
      throw error;
    }
  }

  async sendImageMessage(chatId, imageUrl, caption) {
    try {
      if (!this.isConnected || !this.sock) {
        return { success: false, error: 'WhatsApp not connected' };
      }
      
      console.log(`üì∑ Downloading image from: ${imageUrl}`);
      
      // Download image from URL
      const axios = (await import('axios')).default;
      const imageResponse = await axios.get(imageUrl, { 
        responseType: 'arraybuffer',
        timeout: 15000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      
      const imageBuffer = Buffer.from(imageResponse.data);
      console.log(`üì∑ Image downloaded, size: ${imageBuffer.length} bytes`);
      
      if (imageBuffer.length < 1000) {
        throw new Error('Downloaded image is too small or corrupted');
      }
      
      // Validate image format with sharp
      const sharp = (await import('sharp')).default;
      const metadata = await sharp(imageBuffer).metadata();
      console.log(`üì∑ Image metadata:`, { format: metadata.format, width: metadata.width, height: metadata.height });
      
      // Send as proper image
      await this.sock.sendMessage(chatId, {
        image: imageBuffer,
        caption: caption
      });
      
      console.log('‚úÖ Image sent successfully');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Image message failed:', error.message);
      
      return { success: false, error: error.message };
    }
  }

  async autoReactToMessage(message, messageText) {
    try {
      if (!messageText || messageText.trim().length < 3) return;
      
      // React with 25% probability to avoid spam
      if (Math.random() > 0.25) return;
      
      const reaction = await this.getSmartReaction(messageText);
      
      if (reaction) {
        await this.reactToMessage(message.key, reaction);
        console.log(`ü§ñ NeuraX smartly reacted with ${reaction}`);
      }
    } catch (error) {
      console.error('‚ùå Auto reaction error:', error);
    }
  }

  async getSmartReaction(messageText) {
    try {
      const axios = (await import('axios')).default;
      const apiUrl = process.env.API_URL || process.env.VITE_API_URL || 'http://localhost:5000';
      
      const response = await axios.post(`${apiUrl}/api/ai-chat`, {
        message: `Analyze this message and suggest ONE appropriate emoji reaction. Only respond with the emoji, nothing else: "${messageText}"`,
        model: 'qwen/qwen3-32b',
        systemPrompt: `You are an emoji reaction expert. Analyze the message sentiment and context to suggest the most appropriate single emoji reaction. Choose from these categories:

Positive: üëç ‚ù§Ô∏è üî• ‚ú® üíØ üéâ üòç ü•∞ üí™ üôå üëè üéä üåü üíñ üòä üòÑ ü§© ü•≥
Funny: üòÇ ü§£ üòÜ üòπ ü§™ üòú üôÉ üòã ü§≠ üòè
Surprise: üòÆ ü§Ø üò± üôÄ üò≤ ü§î üßê üëÄ üòØ
Support: üôè ü§ù üíô ü´Ç üëä üíö ü§ó üíú üß° üíõ
Sad: üò¢ üò≠ üíî üòî üòû ü•∫ üòø üò™ üòì
Angry: üò† üò° ü§¨ üò§ üëø üí¢
Neutral: ü§∑ üòê üôÇ üòå üòá ü§®

Respond with ONLY the emoji, no text.`,
        conversationHistory: []
      });
      
      const aiReaction = response.data.response?.trim();
      
      // Validate it's actually an emoji
      if (aiReaction && /^[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]+$/u.test(aiReaction)) {
        return aiReaction;
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå Smart reaction error:', error);
      return null;
    }
  }

  async reactToMessage(messageKey, emoji) {
    try {
      if (!this.isConnected || !this.sock) {
        return { success: false, error: 'WhatsApp not connected' };
      }
      
      await this.sock.sendMessage(messageKey.remoteJid, {
        react: {
          text: emoji,
          key: messageKey
        }
      });
      
      return { success: true };
    } catch (error) {
      console.error('‚ùå Reaction failed:', error);
      return { success: false, error: error.message };
    }
  }

  async sendTypingIndicator(chatId) {
    try {
      if (!this.isConnected || !this.sock) {
        return;
      }
      
      // Show native WhatsApp typing indicator
      await this.sock.sendPresenceUpdate('composing', chatId);
      console.log(`‚å®Ô∏è NeuraX typing indicator shown`);
      
    } catch (error) {
      console.error('‚ùå Typing indicator error:', error);
    }
  }

  async stopTypingIndicator(chatId) {
    try {
      if (!this.isConnected || !this.sock) {
        return;
      }
      
      await this.sock.sendPresenceUpdate('paused', chatId);
    } catch (error) {
      console.error('‚ùå Stop typing error:', error);
    }
  }

  extractPhoneNumber(jid) {
    if (!jid) return '';
    
    // Remove all WhatsApp suffixes
    let phone = jid.replace('@s.whatsapp.net', '').replace('@lid', '').replace('@c.us', '').replace('@g.us', '');
    
    // Handle @lid format which might have extra characters
    if (jid.includes('@lid')) {
      // For @lid, take only the first part before any colon or additional characters
      phone = phone.split(':')[0];
    }
    
    // Remove any non-digit characters except +
    phone = phone.replace(/[^+\d]/g, '');
    
    // Validate phone number length (should be 10-15 digits)
    const digitsOnly = phone.replace(/\D/g, '');
    if (digitsOnly.length < 10 || digitsOnly.length > 15) {
      console.log(`‚ö†Ô∏è Invalid phone length: ${digitsOnly.length} digits - ${phone}`);
      return '';
    }
    
    return phone;
  }

  async checkUserRegistration(senderPhone) {
    try {
      const User = (await import('../models/User.js')).default;
      
      console.log(`üîç Checking registration for phone: ${senderPhone}`);
      
      // Skip if phone is invalid or empty
      if (!senderPhone || senderPhone.length < 10) {
        console.log(`‚ùå Invalid phone number: ${senderPhone}`);
        return false;
      }
      
      // Try multiple phone number formats
      const phoneVariants = [
        senderPhone,                    // Original
        `+${senderPhone}`,             // With +
        senderPhone.startsWith('+') ? senderPhone.substring(1) : senderPhone, // Without +
        senderPhone.startsWith('880') ? senderPhone.substring(3) : senderPhone, // Without country code
        senderPhone.startsWith('880') ? `+${senderPhone}` : `+880${senderPhone}` // Ensure +880 prefix
      ];
      
      console.log(`üîç Trying phone variants:`, phoneVariants);
      
      for (const phoneVariant of phoneVariants) {
        const user = await User.findOne({ phoneNumber: phoneVariant });
        if (user) {
          console.log(`‚úÖ User found with phone: ${phoneVariant} - Username: ${user.username}`);
          return true;
        }
      }
      
      console.log(`‚ùå No user found for any phone variant`);
      return false;
    } catch (error) {
      console.error('‚ùå Error checking user registration:', error);
      return false;
    }
  }

  async handleUnregisteredUser(chatId, senderName, isGroup) {
    try {
      const registrationMessage = `ü§ñ Hi ${senderName}! I'm NeuraX, your AI assistant from Neuronerds Quiz.

üö´ You need to register on our platform to chat with me.

üéÜ **Neuronerds Quiz** - Interactive learning platform with:
‚Ä¢ Quiz battles with friends üèÜ
‚Ä¢ Achievement badges üèÖ
‚Ä¢ Global leaderboards üåç
‚Ä¢ AI-powered learning ü§ñ

üîó **Register here:** https://neuronerdsquiz.vercel.app

Once registered, come back and chat with me! üöÄ`;
      
      const responseText = isGroup ? `@${senderName}\n${registrationMessage}` : registrationMessage;
      
      if (isGroup) {
        await this.sendGroupMessage(chatId, responseText);
      } else {
        await this.sendMessage(chatId, responseText);
      }
      
      console.log(`üö´ Unregistered user ${senderName} prompted to register`);
    } catch (error) {
      console.error('‚ùå Error handling unregistered user:', error);
    }
  }

  async handlePollUpdate(updates) {
    try {
      for (const update of updates) {
        if (update.update.pollUpdate) {
          const pollUpdate = update.update.pollUpdate;
          const messageKey = update.key;
          
          console.log(`üìä Poll response received:`, {
            messageId: messageKey.id,
            voter: pollUpdate.vote?.selectedOptions || 'Unknown',
            pollName: pollUpdate.pollCreationMessage?.name
          });
          
          // You can process poll responses here
          // For example, store in database or send notifications
        }
      }
    } catch (error) {
      console.error('‚ùå Poll update error:', error);
    }
  }

  checkRateLimit(userId, type) {
    const now = Date.now();
    
    if (type === 'message') {
      // 15 messages per minute
      if (!this.messageRequests.has(userId)) {
        this.messageRequests.set(userId, []);
      }
      
      const userRequests = this.messageRequests.get(userId);
      // Remove requests older than 1 minute
      const oneMinuteAgo = now - 60000;
      const recentRequests = userRequests.filter(timestamp => timestamp > oneMinuteAgo);
      
      if (recentRequests.length >= 7) {
        const oldestRequest = Math.min(...recentRequests);
        const waitTime = Math.ceil((oldestRequest + 60000 - now) / 1000);
        return { allowed: false, waitTime };
      }
      
      // Add current request
      recentRequests.push(now);
      this.messageRequests.set(userId, recentRequests);
      return { allowed: true };
    } else if (type === 'image') {
      // 2 images per 5 minutes
      if (!this.imageRequests.has(userId)) {
        this.imageRequests.set(userId, []);
      }
      
      const userRequests = this.imageRequests.get(userId);
      // Remove requests older than 5 minutes
      const fiveMinutesAgo = now - 300000;
      const recentRequests = userRequests.filter(timestamp => timestamp > fiveMinutesAgo);
      
      if (recentRequests.length >= 2) {
        const oldestRequest = Math.min(...recentRequests);
        const waitTime = Math.ceil((oldestRequest + 300000 - now) / 1000);
        return { allowed: false, waitTime };
      }
      
      // Add current request
      recentRequests.push(now);
      this.imageRequests.set(userId, recentRequests);
      return { allowed: true };
    }
    
    return { allowed: true };
  }

  async saveToUserInbox(senderPhone, senderName, message) {
    try {
      const User = (await import('../models/User.js')).default;
      const UserMessage = (await import('../models/UserMessage.js')).default;
      
      // Try to find user by phone number (handle both +880 and 880 formats)
      let recipient = await User.findOne({ phoneNumber: senderPhone });
      
      // If not found, try with +880 prefix
      if (!recipient && !senderPhone.startsWith('+')) {
        recipient = await User.findOne({ phoneNumber: `+${senderPhone}` });
      }
      
      // If still not found, try without +880 prefix
      if (!recipient && senderPhone.startsWith('+')) {
        recipient = await User.findOne({ phoneNumber: senderPhone.substring(1) });
      }
      
      if (!recipient) {
        console.log(`‚ö†Ô∏è No user found with phone ${senderPhone}`);
        return;
      }

      // Save message to inbox
      const inboxMessage = new UserMessage({
        recipientId: recipient._id,
        senderPhone: senderPhone,
        senderName: senderName,
        message: message
      });
      
      await inboxMessage.save();
      console.log(`‚úÖ Message saved to ${recipient.username}'s inbox`);
    } catch (error) {
      console.error('‚ùå Error saving to inbox:', error);
    }
  }
}

// Ensure only one instance per process
if (!global.whatsappServiceInstance) {
  global.whatsappServiceInstance = new WhatsAppService();
}

export default global.whatsappServiceInstance;